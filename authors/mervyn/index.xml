<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Mervyn on 墨客人生</title><link>http://example.org/authors/mervyn/</link><description>Recent content in Mervyn on 墨客人生</description><generator>Hugo</generator><language>zh-cn</language><lastBuildDate>Wed, 26 Nov 2025 10:43:10 +0700</lastBuildDate><atom:link href="http://example.org/authors/mervyn/index.xml" rel="self" type="application/rss+xml"/><item><title>RestTemplate 的 read timed out issue</title><link>http://example.org/posts/spring-boot/rest-template/read-timeout-of-rest-template/</link><pubDate>Wed, 26 Nov 2025 10:43:10 +0700</pubDate><guid>http://example.org/posts/spring-boot/rest-template/read-timeout-of-rest-template/</guid><description>&lt;p&gt;我们维护了两个微服务，微服务 A 和微服务 B。如图1所示微服务 A 通过 RestTemplate 调用微服务 B。其中微服务A的 RestTemplate 通过 HTTPClient 设置了 Read Timeout 为15秒。但是微服务 B 中接口的响应有时候会超过 15秒，这就导致微服务 A 返回第三方微服务的请求会报 500 internal error。&lt;/p&gt;</description></item><item><title>在 Spring Boot 中如何使用 OAuth 2.0 Client</title><link>http://example.org/posts/spring-boot/how-to-use-oauth-2-client-in-spring-boot/</link><pubDate>Sat, 15 Feb 2025 10:10:42 +0700</pubDate><guid>http://example.org/posts/spring-boot/how-to-use-oauth-2-client-in-spring-boot/</guid><description>&lt;h1 id="背景"&gt;
 背景
 &lt;a class="heading-link" href="#%e8%83%8c%e6%99%af"&gt;
 &lt;i class="fa-solid fa-link" aria-hidden="true" title="链接到标题"&gt;&lt;/i&gt;
 &lt;span class="sr-only"&gt;链接到标题&lt;/span&gt;
 &lt;/a&gt;
&lt;/h1&gt;
&lt;p&gt;目前有两个微服务 A 和 B，微服务 A 访问微服务 B 之前需要从授权服务器中获取 Access Token，才能携带 Access Token 访问微服务 B 中的 Restful API，如图 1 所示。微服务 A 使用客户端模式（Client Credentials Grant）的方式，从授权服务器获取 Access Token。目前微服务 A 通过 RestTemplate，从授权服务器获取 Access Token，并通过 Ehcache 来缓存 Access Token。&lt;/p&gt;</description></item><item><title>软件研发人员的质量保证实践【部分】</title><link>http://example.org/posts/servlet-book/quality-assurance-practices-for-software-developers/</link><pubDate>Sun, 09 Feb 2025 21:48:32 +0700</pubDate><guid>http://example.org/posts/servlet-book/quality-assurance-practices-for-software-developers/</guid><description>&lt;h3 id="1191-进程内集成测试"&gt;
 11.9.1 进程内集成测试
 &lt;a class="heading-link" href="#1191-%e8%bf%9b%e7%a8%8b%e5%86%85%e9%9b%86%e6%88%90%e6%b5%8b%e8%af%95"&gt;
 &lt;i class="fa-solid fa-link" aria-hidden="true" title="链接到标题"&gt;&lt;/i&gt;
 &lt;span class="sr-only"&gt;链接到标题&lt;/span&gt;
 &lt;/a&gt;
&lt;/h3&gt;
&lt;p&gt;进程内集成测试是一种针对应用程序内部组件和模块之间的集成进行测试的方法。它主要关注应用程序内部各个组件之间的协同工作、通信和数据流，以验证它们在应用程序运行时是否能够正确地交互和合作。&lt;/p&gt;</description></item><item><title>第八章 协议升级和非阻塞 IO【部分】</title><link>http://example.org/posts/servlet-book/protocal-upgrades-and-no-blocking-io/</link><pubDate>Sun, 09 Feb 2025 21:31:20 +0700</pubDate><guid>http://example.org/posts/servlet-book/protocal-upgrades-and-no-blocking-io/</guid><description>&lt;p&gt;Servlet 所提供的非阻塞 IO 仅可以在 Servlet 异步处理和协议升级中使用。我们在第七章已经详细阐述了 Servlet 异步处理，因此本章首先简单阐述 Servlet 对协议升级的支持，然后重点阐述 Servlet 为支持非阻塞 IO 所提供的相关 API 以及通过示例来说明它们的使用场景和用法。&lt;/p&gt;</description></item><item><title>第七章 异步处理【部分】</title><link>http://example.org/posts/servlet-book/asynchronous/</link><pubDate>Sun, 09 Feb 2025 20:46:04 +0700</pubDate><guid>http://example.org/posts/servlet-book/asynchronous/</guid><description>&lt;p&gt;本章将介绍 Servlet API 3.0 引入的对异步处理的支持。异步处理是为了减少同步处理中会出现的阻塞和等待问题，对系统吞吐率等影响。通过异步处理可以充分利用服务器资源，提高系统性能和响应速度。本章将从尝试回答异步处理尝试解决的问题开始，逐步介绍 Servlet API 对异步处理的支持和异步处理的典型顺序。紧接着通过具体的示例演示异步处理的过程，让读者对 Servlet 的异步处理有一个直观的认识并体会其优势。最后也会阐述异步处理具体的适用场景。通过学习本章，您将能够了解 Servlet 异步处理的基本概念和实现方式，以及如何利用其提高系统的性能。&lt;/p&gt;</description></item><item><title>Spring Boot 中如何设置 serializer 的 TimeZone</title><link>http://example.org/posts/how_to_configure_timezone_for_serializer_in_spring_boot/</link><pubDate>Sun, 24 Nov 2024 22:03:04 +0800</pubDate><guid>http://example.org/posts/how_to_configure_timezone_for_serializer_in_spring_boot/</guid><description>&lt;h2 id="1-背景"&gt;
 1 背景
 &lt;a class="heading-link" href="#1-%e8%83%8c%e6%99%af"&gt;
 &lt;i class="fa-solid fa-link" aria-hidden="true" title="链接到标题"&gt;&lt;/i&gt;
 &lt;span class="sr-only"&gt;链接到标题&lt;/span&gt;
 &lt;/a&gt;
&lt;/h2&gt;
&lt;p&gt;在一个基于 Spring Boot 的服务中，对外提供一个 Restful 接口 A。该接口的返回值类型中包含一个 ZonedDateTime 类型的字段 createdDateTime。Prod 代码侧期望返回时区为 Australia/Sydney（UTC+10/UTC+10）的时间，并带有时区信息，例如，2024-11-03T08:23:24+11:00。并且测试侧代码也是按照期望进行了测试，测试在 Pipeline 和澳洲 Dev 的本地电脑中可以通过。测试示例如代码1所示。但是该代码确不能在中国 Dev 的本地电脑上工作。&lt;/p&gt;</description></item><item><title>如何修改最后一次 commit 的 author 信息</title><link>http://example.org/posts/git/change-the-author-of-last-commit/</link><pubDate>Sat, 20 Jan 2024 09:56:01 +0800</pubDate><guid>http://example.org/posts/git/change-the-author-of-last-commit/</guid><description>&lt;p&gt;在新 repository 提交代码时，有时忘记配置该 repository scope 内的 &lt;code&gt;user.name&lt;/code&gt; 和 &lt;code&gt;user.email&lt;/code&gt;，从而导致 commit 的 author 信息为 global 配置的 &lt;code&gt;user.name&lt;/code&gt; 和 &lt;code&gt;user.email&lt;/code&gt;。如果此时想要修改最新提交的 author 信息，可以使用下面的 command:&lt;/p&gt;</description></item><item><title>由 Reactor Netty HttpClient 的 response-timeout 设置错误引发的生产事故的反思</title><link>http://example.org/posts/rethink-of-production-incident-caused-by-the-wrong-configuration-of-respond-timeout-in-terms-of-reactor-netty-httpclient/</link><pubDate>Wed, 17 Jan 2024 05:07:38 +0800</pubDate><guid>http://example.org/posts/rethink-of-production-incident-caused-by-the-wrong-configuration-of-respond-timeout-in-terms-of-reactor-netty-httpclient/</guid><description>&lt;p&gt;在 onCall 的过程中，发生了一起由 Reactor Netty HttpClient 的 response-timeout 设置错误引发的 P2 级生产事故。造成了系统 1.5 小时部分功能不可用，使客户遭受了经济上的损失。本文期望针对完整的事件进行复盘与反思，以加强自己对线上环境的敬畏。&lt;/p&gt;</description></item><item><title>How to Set Username and Email in Git</title><link>http://example.org/posts/git/how-to-set-username-and-email-in-git/</link><pubDate>Tue, 26 Dec 2023 20:10:48 +0800</pubDate><guid>http://example.org/posts/git/how-to-set-username-and-email-in-git/</guid><description>&lt;p&gt;Git 中的 &lt;code&gt;user.name&lt;/code&gt; 和 &lt;code&gt;user.email&lt;/code&gt; 的 scope 的范围可以为单个 repository 的或全局的。利用这点上下文，我们可以很好解决多个 repository 中的 commit 需要不同 &lt;code&gt;Author&lt;/code&gt; 的问题。下面首先分别阐述如何设置 scope 为单个 repository 和如何设置全局的的&lt;code&gt;user.name&lt;/code&gt; 和 &lt;code&gt;user.email&lt;/code&gt;。&lt;/p&gt;</description></item></channel></rss>