<!doctype html><html lang=zh-cn><head><title>第七章 异步处理【部分】 · 墨客人生</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=color-scheme content="light dark"><meta name=author content="Mervyn"><meta name=description content="本章将介绍 Servlet API 3.0 引入的对异步处理的支持。异步处理是为了减少同步处理中会出现的阻塞和等待问题，对系统吞吐率等影响。通过异步处理可以充分利用服务器资源，提高系统性能和响应速度。本章将从尝试回答异步处理尝试解决的问题开始，逐步介绍 Servlet API 对异步处理的支持和异步处理的典型顺序。紧接着通过具体的示例演示异步处理的过程，让读者对 Servlet 的异步处理有一个直观的认识并体会其优势。最后也会阐述异步处理具体的适用场景。通过学习本章，您将能够了解 Servlet 异步处理的基本概念和实现方式，以及如何利用其提高系统的性能。"><meta name=keywords content="blog,developer,personal"><meta name=twitter:card content="summary"><meta name=twitter:title content="第七章 异步处理【部分】"><meta name=twitter:description content="本章将介绍 Servlet API 3.0 引入的对异步处理的支持。异步处理是为了减少同步处理中会出现的阻塞和等待问题，对系统吞吐率等影响。通过异步处理可以充分利用服务器资源，提高系统性能和响应速度。本章将从尝试回答异步处理尝试解决的问题开始，逐步介绍 Servlet API 对异步处理的支持和异步处理的典型顺序。紧接着通过具体的示例演示异步处理的过程，让读者对 Servlet 的异步处理有一个直观的认识并体会其优势。最后也会阐述异步处理具体的适用场景。通过学习本章，您将能够了解 Servlet 异步处理的基本概念和实现方式，以及如何利用其提高系统的性能。"><meta property="og:url" content="http://example.org/posts/servlet-book/asynchronous/"><meta property="og:site_name" content="墨客人生"><meta property="og:title" content="第七章 异步处理【部分】"><meta property="og:description" content="本章将介绍 Servlet API 3.0 引入的对异步处理的支持。异步处理是为了减少同步处理中会出现的阻塞和等待问题，对系统吞吐率等影响。通过异步处理可以充分利用服务器资源，提高系统性能和响应速度。本章将从尝试回答异步处理尝试解决的问题开始，逐步介绍 Servlet API 对异步处理的支持和异步处理的典型顺序。紧接着通过具体的示例演示异步处理的过程，让读者对 Servlet 的异步处理有一个直观的认识并体会其优势。最后也会阐述异步处理具体的适用场景。通过学习本章，您将能够了解 Servlet 异步处理的基本概念和实现方式，以及如何利用其提高系统的性能。"><meta property="og:locale" content="zh_cn"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-02-09T20:46:04+07:00"><meta property="article:modified_time" content="2025-02-09T20:46:04+07:00"><link rel=canonical href=http://example.org/posts/servlet-book/asynchronous/><link rel=preload href=/fonts/fa-brands-400.woff2 as=font type=font/woff2 crossorigin><link rel=preload href=/fonts/fa-regular-400.woff2 as=font type=font/woff2 crossorigin><link rel=preload href=/fonts/fa-solid-900.woff2 as=font type=font/woff2 crossorigin><link rel=stylesheet href=/css/coder.min.60f552a2c0452fcc0254c54f21c3e0728460c1ae85f97a9c35833a222ef8b884.css integrity="sha256-YPVSosBFL8wCVMVPIcPgcoRgwa6F+XqcNYM6Ii74uIQ=" crossorigin=anonymous media=screen><link rel=stylesheet href=/css/coder-dark.min.a00e6364bacbc8266ad1cc81230774a1397198f8cfb7bcba29b7d6fcb54ce57f.css integrity="sha256-oA5jZLrLyCZq0cyBIwd0oTlxmPjPt7y6KbfW/LVM5X8=" crossorigin=anonymous media=screen><link rel=icon type=image/svg+xml href=/images/favicon.svg sizes=any><link rel=icon type=image/png href=/img/favicon-32x32.png sizes=32x32><link rel=icon type=image/png href=/img/favicon-16x16.png sizes=16x16><link rel=apple-touch-icon href=/images/apple-touch-icon.png><link rel=apple-touch-icon sizes=180x180 href=/images/apple-touch-icon.png><link rel=manifest href=/site.webmanifest><link rel=mask-icon href=/images/safari-pinned-tab.svg color=#5bbad5></head><body class="preload-transitions colorscheme-auto"><div class=float-container><a id=dark-mode-toggle class=colorscheme-toggle><i class="fa-solid fa-adjust fa-fw" aria-hidden=true></i></a></div><main class=wrapper><nav class=navigation><section class=container><a class=navigation-title href=http://example.org/>墨客人生
</a><input type=checkbox id=menu-toggle>
<label class="menu-button float-right" for=menu-toggle><i class="fa-solid fa-bars fa-fw" aria-hidden=true></i></label><ul class=navigation-list><li class=navigation-item><a class=navigation-link href=/life/>生活</a></li><li class=navigation-item><a class=navigation-link href=/posts/>博客</a></li><li class=navigation-item><a class=navigation-link href=/about-me>关于我</a></li></ul></section></nav><div class=content><section class="container post"><article><header><div class=post-title><h1 class=title><a class=title-link href=http://example.org/posts/servlet-book/asynchronous/>第七章 异步处理【部分】</a></h1></div><div class=post-meta><div class=date><span class=posted-on><i class="fa-solid fa-calendar" aria-hidden=true></i>
<time datetime=2025-02-09T20:46:04+07:00>February 9, 2025
</time></span><span class=reading-time><i class="fa-solid fa-clock" aria-hidden=true></i>
阅读时间：7 分钟
</span><span class=post-word-count>| 🍉 3225 字</span></div><div class=authors><i class="fa-solid fa-user" aria-hidden=true></i>
<a href=/authors/mervyn/>Mervyn</a></div></div></header><div class=post-content><p>本章将介绍 Servlet API 3.0 引入的对异步处理的支持。异步处理是为了减少同步处理中会出现的阻塞和等待问题，对系统吞吐率等影响。通过异步处理可以充分利用服务器资源，提高系统性能和响应速度。本章将从尝试回答异步处理尝试解决的问题开始，逐步介绍 Servlet API 对异步处理的支持和异步处理的典型顺序。紧接着通过具体的示例演示异步处理的过程，让读者对 Servlet 的异步处理有一个直观的认识并体会其优势。最后也会阐述异步处理具体的适用场景。通过学习本章，您将能够了解 Servlet 异步处理的基本概念和实现方式，以及如何利用其提高系统的性能。</p><h2 id=71-异步处理尝试解决的问题是什么>7.1 异步处理尝试解决的问题是什么？
<a class=heading-link href=#71-%e5%bc%82%e6%ad%a5%e5%a4%84%e7%90%86%e5%b0%9d%e8%af%95%e8%a7%a3%e5%86%b3%e7%9a%84%e9%97%ae%e9%a2%98%e6%98%af%e4%bb%80%e4%b9%88><i class="fa-solid fa-link" aria-hidden=true title=链接到标题></i>
<span class=sr-only>链接到标题</span></a></h2><p>过滤器或 Servlet 在处理请求时，存在一些场景需要依赖某些资源或等待某个事件。在这些资源或事件没有就绪的情况下，他们无法完成请求的处理。例如，在生成响应之前，Servlet 可能需要等待可用的 JDBC 连接、等待IO操作、来自远程 Web 服务的响应、JMS 消息或应用程序事件等。如果在同步处理模式下，通常需要在过滤器或 Servlet 中等待。在过滤器或 Servlet 中等待是一种低效方式，因为它是一种消耗线程和其他有限资源的阻塞操作。通常，一个缓慢的资源（如数据库）可能有许多 Servlet 容器的线程阻塞等待访问，并可能导致线程饥饿和整个 Web 容器的服务质量低下。而使用异步处理的方式，则可以将阻塞操作交由另一个业务线程或业务线程池处理，原本容器处理请求的工作线程可以在不提交响应的情况下立即返回线程池，去处理其它的请求或任务，从而提高了系统的吞吐量和并发能力。笔者认为这就是异步处理在尝试解决的核心问题。此外，异步处理还可以利用并行，减少客户端的等待时间，提高系统的响应速度，增强用户体验。</p><h2 id=72-servlet-api-30-对异步的支持>7.2 Servlet API 3.0 对异步的支持
<a class=heading-link href=#72-servlet-api-30-%e5%af%b9%e5%bc%82%e6%ad%a5%e7%9a%84%e6%94%af%e6%8c%81><i class="fa-solid fa-link" aria-hidden=true title=链接到标题></i>
<span class=sr-only>链接到标题</span></a></h2><p>为了支持异步操作，Servlet API 从 3.0 版本开始引入了一些新的改变，包括：</p><ol><li>使 Servlet 和过滤器可以配置是否开启对异步操作的支持。</li><li>AsyncContext 接口：这个接口是支持 Servlet 异步操作的核心接口。通过该接口 Servlet 可以创建一个异步上下文对象，然后通过这个对象来进行异步操作的管理。</li><li>在 ServletRequest 类中增加了的支持异步的相关方法。</li><li>AsyncEvent 类和 AsyncListener 接口，作为异步事件类和异步事件监听器。</li></ol><p>上面这些一起构成了 Servlet API 中异步操作的完整机制，方便开发者进行异步操作的编写和管理。接下来我们对它们进行简单的介绍。</p><h2 id=721-servlet-如何开启异步处理的支持>7.2.1 Servlet 如何开启异步处理的支持
<a class=heading-link href=#721-servlet-%e5%a6%82%e4%bd%95%e5%bc%80%e5%90%af%e5%bc%82%e6%ad%a5%e5%a4%84%e7%90%86%e7%9a%84%e6%94%af%e6%8c%81><i class="fa-solid fa-link" aria-hidden=true title=链接到标题></i>
<span class=sr-only>链接到标题</span></a></h2><p>在 2.7 节中我们了解了配置 Servlet 的三种方式，因此 Servlet 也支持这三种方式开启异步处理。</p><h3 id=1在-webxml-中开启-servlet-对异步处理的支持>1)、在 web.xml 中开启 Servlet 对异步处理的支持
<a class=heading-link href=#1%e5%9c%a8-webxml-%e4%b8%ad%e5%bc%80%e5%90%af-servlet-%e5%af%b9%e5%bc%82%e6%ad%a5%e5%a4%84%e7%90%86%e7%9a%84%e6%94%af%e6%8c%81><i class="fa-solid fa-link" aria-hidden=true title=链接到标题></i>
<span class=sr-only>链接到标题</span></a></h3><p>从 2.7.1 节的表 2.1 中，我们获知了 web.xml 里面<code>&lt;servlet></code> 元素中的<code>&lt;async-supported></code> 元素的作用。我们可以通过 <code>&lt;async-supported></code> 元素，将该元素对于的值设置成 true，从而表示相应的 Servlet 开启了对异步处理的支持。如果在 <code>&lt;servlet></code> 元素中不定义 <code>&lt;async-supported></code> 元素，则该元素所对应的默认值为 false。<code>&lt;async-supported></code> 元素的值为 false, 则表明该 Servlet 不支持异步处理。</p><p>如代码清单 7.1 所示，我们可以在 web.xml 中配置 <code>&lt;servlet></code> 元素，并且在该元素中配置 <code>&lt;async-supported></code> 元素，将其值设置为 true，从而表示 AsynchronousServlet 开启了对异步处理的支持。</p><p>代码清单7.1 在 web.xml 中开启 Servlet 对异步处理的支持：web.xml</p><div class=highlight><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-xml data-lang=xml><span style=display:flex><span><span style=color:#8b949e;font-weight:700;font-style:italic>&lt;?xml version=&#34;1.0&#34; encoding=&#34;UTF-8&#34;?&gt;</span>
</span></span><span style=display:flex><span><span style=color:#7ee787>&lt;web-app</span> xmlns=<span style=color:#a5d6ff>&#34;https://jakarta.ee/xml/ns/jakartaee&#34;</span>
</span></span><span style=display:flex><span>         xmlns:xsi=<span style=color:#a5d6ff>&#34;http://www.w3.org/2001/XMLSchema-instance&#34;</span>
</span></span><span style=display:flex><span>         xsi:schemaLocation=<span style=color:#a5d6ff>&#34;https://jakarta.ee/xml/ns/jakartaee https://jakarta.ee/xml/ns/jakartaee/web-app_6_0.xsd&#34;</span>
</span></span><span style=display:flex><span>         version=<span style=color:#a5d6ff>&#34;6.0&#34;</span><span style=color:#7ee787>&gt;</span>
</span></span><span style=display:flex><span>    <span style=color:#7ee787>&lt;servlet&gt;</span>
</span></span><span style=display:flex><span>        <span style=color:#7ee787>&lt;servlet-name&gt;</span>asynchronous-servlet<span style=color:#7ee787>&lt;/servlet-name&gt;</span>
</span></span><span style=display:flex><span>        <span style=color:#7ee787>&lt;servlet-class&gt;</span>com.mervyn.learn.servlet.AsynchronousServlet<span style=color:#7ee787>&lt;/servlet-class&gt;</span>
</span></span><span style=display:flex><span>        <span style=color:#7ee787>&lt;async-supported&gt;</span>true<span style=color:#7ee787>&lt;/async-supported&gt;</span>
</span></span><span style=display:flex><span>    <span style=color:#7ee787>&lt;/servlet&gt;</span>
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>    <span style=color:#7ee787>&lt;servlet-mapping&gt;</span>
</span></span><span style=display:flex><span>        <span style=color:#7ee787>&lt;servlet-name&gt;</span>asynchronous-servlet<span style=color:#7ee787>&lt;/servlet-name&gt;</span>
</span></span><span style=display:flex><span>        <span style=color:#7ee787>&lt;url-pattern&gt;</span>/asynchronous<span style=color:#7ee787>&lt;/url-pattern&gt;</span>
</span></span><span style=display:flex><span>    <span style=color:#7ee787>&lt;/servlet-mapping&gt;</span>
</span></span><span style=display:flex><span><span style=color:#7ee787>&lt;/web-app&gt;</span>
</span></span></code></pre></div><h3 id=2使用注解方式开启-servlet-对异步处理的支持>2)、使用注解方式开启 Servlet 对异步处理的支持
<a class=heading-link href=#2%e4%bd%bf%e7%94%a8%e6%b3%a8%e8%a7%a3%e6%96%b9%e5%bc%8f%e5%bc%80%e5%90%af-servlet-%e5%af%b9%e5%bc%82%e6%ad%a5%e5%a4%84%e7%90%86%e7%9a%84%e6%94%af%e6%8c%81><i class="fa-solid fa-link" aria-hidden=true title=链接到标题></i>
<span class=sr-only>链接到标题</span></a></h3><p>从 2.7.2 节的表 2.2 中，我们了解到了通过 <code>@WebServlet</code> 的 asyncSupported 属性，可以开启或关闭 Servlet 对异步的支持。如果将该属性的值设置为 true，则表明标注此 <code>@WebServlet</code> 的 Servlet 开启了对异步的支持。如果不设置该属性的值或将该属性指定为 false，则表明标注此 <code>@WebServlet</code> 的 Servlet 不支持异步。</p><p>代码清单7.2 使用注解方式开启 Servlet 对异步处理的支持代码片段：AsynchronousServlet.java</p><p>如代码清单 7.2 所示，我们将 <code>@WebServlet</code> 注解的 asyncSupported 属性，将其值设置为 true，从而表示 AsynchronousServlet 开启了对异步处理的支持。</p><div class=highlight><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#d2a8ff;font-weight:700>@WebServlet</span>(value<span style=color:#6e7681> </span><span style=color:#ff7b72;font-weight:700>=</span><span style=color:#6e7681> </span><span style=color:#a5d6ff>&#34;/asynchronous&#34;</span>,<span style=color:#6e7681> </span>asyncSupported<span style=color:#6e7681> </span><span style=color:#ff7b72;font-weight:700>=</span><span style=color:#6e7681> </span><span style=color:#79c0ff>true</span>)<span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681></span><span style=color:#ff7b72>public</span><span style=color:#6e7681> </span><span style=color:#ff7b72>class</span> <span style=color:#f0883e;font-weight:700>AsynchronousServlet</span><span style=color:#6e7681> </span><span style=color:#ff7b72>extends</span><span style=color:#6e7681> </span>HttpServlet<span style=color:#6e7681> </span>{<span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681>    </span><span style=color:#8b949e;font-style:italic>// ...</span><span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681></span>}<span style=color:#6e7681>
</span></span></span></code></pre></div><h3 id=3通过编程方式开启-servlet-对异步处理的支持>3)、通过编程方式开启 Servlet 对异步处理的支持
<a class=heading-link href=#3%e9%80%9a%e8%bf%87%e7%bc%96%e7%a8%8b%e6%96%b9%e5%bc%8f%e5%bc%80%e5%90%af-servlet-%e5%af%b9%e5%bc%82%e6%ad%a5%e5%a4%84%e7%90%86%e7%9a%84%e6%94%af%e6%8c%81><i class="fa-solid fa-link" aria-hidden=true title=链接到标题></i>
<span class=sr-only>链接到标题</span></a></h3><p>从 2.7.3 节的表 2.3 中，我们了解到通过 ServletRegistration.Dynamic 的 <code>setAsyncSupported(boolean isAsyncSupported)</code> 的方法可以开启或关闭 Servlet 对异步的支持。如果调用该方法时使用的 isAsyncSupported 参数的值为 true，则相应的 Servlet 开启了对异步的支持。如果不调用该方法或使用 false 作为参数调用该方法，则表明相应的 Servlet 不支持异步。</p><p>如代码清单 7.3 所示，我们将 true 作为参数调用 ServletRegistration.Dynamic 的 setAsyncSupported 方法，从而表示 AsynchronousServlet 开启了对异步处理的支持。</p><p>代码清单7.3 通过编程方式开启 Servlet 对异步处理的支持代码片段 CustomServletContextListener.java</p><div class=highlight><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#d2a8ff;font-weight:700>@WebListener</span><span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681></span><span style=color:#ff7b72>public</span><span style=color:#6e7681> </span><span style=color:#ff7b72>class</span> <span style=color:#f0883e;font-weight:700>CustomServletContextListener</span><span style=color:#6e7681> </span><span style=color:#ff7b72>implements</span><span style=color:#6e7681> </span>ServletContextListener<span style=color:#6e7681> </span>{<span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681>    </span><span style=color:#d2a8ff;font-weight:700>@Override</span><span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681>    </span><span style=color:#ff7b72>public</span><span style=color:#6e7681> </span><span style=color:#ff7b72>void</span><span style=color:#6e7681> </span><span style=color:#d2a8ff;font-weight:700>contextInitialized</span>(ServletContextEvent<span style=color:#6e7681> </span>servletContextEvent)<span style=color:#6e7681> </span>{<span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681>        </span>ServletContext<span style=color:#6e7681> </span>servletContext<span style=color:#6e7681> </span><span style=color:#ff7b72;font-weight:700>=</span><span style=color:#6e7681> </span>servletContextEvent.getServletContext();<span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681>        </span>ServletRegistration.Dynamic<span style=color:#6e7681> </span>asynchronousServletRegistration<span style=color:#6e7681> </span><span style=color:#ff7b72;font-weight:700>=</span><span style=color:#6e7681> </span>servletContext.addServlet(<span style=color:#a5d6ff>&#34;asynchronousServlet&#34;</span>,<span style=color:#6e7681> </span>AsynchronousServlet.class);<span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681>        </span>asynchronousServletRegistration.addMapping(<span style=color:#a5d6ff>&#34;/asynchronous&#34;</span>);<span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681>        </span>asynchronousServletRegistration.setAsyncSupported(<span style=color:#79c0ff>true</span>);<span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681>    </span>}<span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681></span>}<span style=color:#6e7681>
</span></span></span></code></pre></div><p>需要注意的是，无论通过上述哪种方法开启 Servlet 对异步处理的支持，这仅仅表明指定的 Servlet 可以或能够支持异步处理。如果需要开启一个异步处理，还需要调用 ServletRequest 接口中的 <code>startAsync()</code> 或 <code>startAsync(ServletRequest servletRequest, ServletResponse servletResponse)</code> 方法。这样容器并不会提交响应，同时原始线程也会退出 Servlet 并返回线程池。在异步处理执行的过程，直到调用 AsyncContext 上的 <code>complete()</code> 方法以后，容器才会提交响应。同时需要注意的是，在容器通过调用 startAsync 方法发起的分派返回之前，如果异步任务已经开始执行，那么应用程序就需要负责处理请求和响应对象的并发访问。</p><p>如果 Servlet 仅是开启了对异步处理的支持，请求过滤器和 Servlet 没有调用任何的 <code>startAsync</code> 方法，那么容器会将该 Servlet 按照同步的方式处理请求。如果在 Servlet 中没有开启对异步处理的支持，但却尝试调用任何的 startAsync 方法，那么容器会抛出 IllegalStateException 异常。当然我们需要在实际的开发过程中避免这种充满歧义的情况，让 Servlet 的处理模式与其行为保持一致。</p><h2 id=722-过滤器如何开启异步处理的支持>7.2.2 过滤器如何开启异步处理的支持
<a class=heading-link href=#722-%e8%bf%87%e6%bb%a4%e5%99%a8%e5%a6%82%e4%bd%95%e5%bc%80%e5%90%af%e5%bc%82%e6%ad%a5%e5%a4%84%e7%90%86%e7%9a%84%e6%94%af%e6%8c%81><i class="fa-solid fa-link" aria-hidden=true title=链接到标题></i>
<span class=sr-only>链接到标题</span></a></h2><p>在 6.6 节中我们了解了配置过滤器的三种方式，因此过滤器需要开启异步处理的支持，也支持这三方方式。</p><h3 id=1在-webxml-中开启过滤器对异步处理的支持>1)、在 web.xml 中开启过滤器对异步处理的支持
<a class=heading-link href=#1%e5%9c%a8-webxml-%e4%b8%ad%e5%bc%80%e5%90%af%e8%bf%87%e6%bb%a4%e5%99%a8%e5%af%b9%e5%bc%82%e6%ad%a5%e5%a4%84%e7%90%86%e7%9a%84%e6%94%af%e6%8c%81><i class="fa-solid fa-link" aria-hidden=true title=链接到标题></i>
<span class=sr-only>链接到标题</span></a></h3><p>通过 6.6.1 节的表 6-1 我们了解到，可以通过 <code>&lt;filter></code> 元素中的<code>&lt;async-supported></code> 元素来设置过滤器是否支持异步操作。如果过滤器支持异步操作，需要将该 <code>&lt;async-supported></code> 元素的值设置成 true。如果将该元素的值设置 false，则意味着过滤器不支持异步操作。如果<code>&lt;filter></code> 元素中没有声明 <code>&lt;async-supported></code> 元素，那么默认值为 false。</p><p>如代码清单7.4 所示，我们在 web.xml 中配置了一个名为 asynchronousFilter 过滤器，通过将 <code>&lt;async-supported></code> 元素的值设置成 true，表明该过滤器支持异步操作。</p><p>代码清单7.4 在 web.xml 中开启过滤器对异步处理的支持：web.xml</p><div class=highlight><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-xml data-lang=xml><span style=display:flex><span><span style=color:#8b949e;font-weight:700;font-style:italic>&lt;?xml version=&#34;1.0&#34; encoding=&#34;UTF-8&#34;?&gt;</span>
</span></span><span style=display:flex><span><span style=color:#7ee787>&lt;web-app</span> xmlns=<span style=color:#a5d6ff>&#34;https://jakarta.ee/xml/ns/jakartaee&#34;</span>
</span></span><span style=display:flex><span>         xmlns:xsi=<span style=color:#a5d6ff>&#34;http://www.w3.org/2001/XMLSchema-instance&#34;</span>
</span></span><span style=display:flex><span>         xsi:schemaLocation=<span style=color:#a5d6ff>&#34;https://jakarta.ee/xml/ns/jakartaee https://jakarta.ee/xml/ns/jakartaee/web-app_6_0.xsd&#34;</span>
</span></span><span style=display:flex><span>         version=<span style=color:#a5d6ff>&#34;6.0&#34;</span><span style=color:#7ee787>&gt;</span>
</span></span><span style=display:flex><span>    <span style=color:#7ee787>&lt;filter&gt;</span>
</span></span><span style=display:flex><span>        <span style=color:#7ee787>&lt;filter-name&gt;</span>asynchronousFilter<span style=color:#7ee787>&lt;/filter-name&gt;</span>
</span></span><span style=display:flex><span>        <span style=color:#7ee787>&lt;filter-class&gt;</span>com.mervyn.learn.servlet.AsynchronousFilter<span style=color:#7ee787>&lt;/filter-class&gt;</span>
</span></span><span style=display:flex><span>        <span style=color:#7ee787>&lt;async-supported&gt;</span>true<span style=color:#7ee787>&lt;/async-supported&gt;</span>
</span></span><span style=display:flex><span>    <span style=color:#7ee787>&lt;/filter&gt;</span>
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#7ee787>&lt;filter-mapping&gt;</span>
</span></span><span style=display:flex><span>        <span style=color:#7ee787>&lt;filter-name&gt;</span>asynchronousFilter<span style=color:#7ee787>&lt;/filter-name&gt;</span>
</span></span><span style=display:flex><span>        <span style=color:#7ee787>&lt;url-pattern&gt;</span>/asynchronous<span style=color:#7ee787>&lt;/url-pattern&gt;</span>
</span></span><span style=display:flex><span>    <span style=color:#7ee787>&lt;/filter-mapping&gt;</span>
</span></span><span style=display:flex><span><span style=color:#7ee787>&lt;/web-app&gt;</span>
</span></span></code></pre></div><h3 id=2使用注解方式开启过滤器对异步处理的支持>2)、使用注解方式开启过滤器对异步处理的支持
<a class=heading-link href=#2%e4%bd%bf%e7%94%a8%e6%b3%a8%e8%a7%a3%e6%96%b9%e5%bc%8f%e5%bc%80%e5%90%af%e8%bf%87%e6%bb%a4%e5%99%a8%e5%af%b9%e5%bc%82%e6%ad%a5%e5%a4%84%e7%90%86%e7%9a%84%e6%94%af%e6%8c%81><i class="fa-solid fa-link" aria-hidden=true title=链接到标题></i>
<span class=sr-only>链接到标题</span></a></h3><p>通过 6.6.2 节的表 6-2 @WebFilter 属性说明，我们了解到可以通过该注解的 asyncSupported 属性，来设置过滤器是否支持异步操作。如果过滤器支持异步操作，需要将 @WebFilter 中的 asyncSupported 属性的值设置成 true。如果该该属性的值设置为 false, 则意味着过滤器不支持异步操作。如果 @WebFilter 中不声明 asyncSupported 属性，则 asyncSupported 的值默为 false。关于 asyncSupported 属性的配置，可参考代码清单7.5。</p><p>代码清单7.5 使用注解方式开启过滤器对异步处理的支持代码片段：AsynchronousFilter.java</p><div class=highlight><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#d2a8ff;font-weight:700>@WebFilter</span>(urlPatterns<span style=color:#6e7681> </span><span style=color:#ff7b72;font-weight:700>=</span><span style=color:#6e7681> </span>{<span style=color:#a5d6ff>&#34;/asynchronous&#34;</span>},<span style=color:#6e7681> </span>asyncSupported<span style=color:#6e7681> </span><span style=color:#ff7b72;font-weight:700>=</span><span style=color:#6e7681> </span><span style=color:#79c0ff>true</span>)<span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681></span><span style=color:#ff7b72>public</span><span style=color:#6e7681> </span><span style=color:#ff7b72>class</span> <span style=color:#f0883e;font-weight:700>AsynchronousFilter</span><span style=color:#6e7681> </span><span style=color:#ff7b72>extends</span><span style=color:#6e7681> </span>HttpFilter<span style=color:#6e7681> </span>{<span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681>    </span><span style=color:#8b949e;font-style:italic>// ......</span><span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681></span>}<span style=color:#6e7681>
</span></span></span></code></pre></div><h3 id=3通过编程方式开启过滤器对异步处理的支持>3)、通过编程方式开启过滤器对异步处理的支持
<a class=heading-link href=#3%e9%80%9a%e8%bf%87%e7%bc%96%e7%a8%8b%e6%96%b9%e5%bc%8f%e5%bc%80%e5%90%af%e8%bf%87%e6%bb%a4%e5%99%a8%e5%af%b9%e5%bc%82%e6%ad%a5%e5%a4%84%e7%90%86%e7%9a%84%e6%94%af%e6%8c%81><i class="fa-solid fa-link" aria-hidden=true title=链接到标题></i>
<span class=sr-only>链接到标题</span></a></h3><p>通过 4.4.3 节，我们了解如何以编程方式添加和配置过滤器。我们可以使用 true 作为参数值，调用 FilterRegistration.Dynamic 的 setAsyncSupported 方法，用来设置过滤器是支持异步操作的。如果使用 false 作为参数值调用该方法，或者配置过滤器的过程中不调用该方法，则表示过滤器不支持异步操作。</p><p>如代码清单7.6所示，我们通过调用 FilterRegistration.Dynamic 的 setAsyncSupported 方法，将设置 asynchronousFilter 为支持异步操作。</p><p>代码清单7.6 通过编程方式开启过滤器对异步处理的支持代码片段：CustomServletContextListener.java</p><div class=highlight><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#d2a8ff;font-weight:700>@WebListener</span><span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681></span><span style=color:#ff7b72>public</span><span style=color:#6e7681> </span><span style=color:#ff7b72>class</span> <span style=color:#f0883e;font-weight:700>CustomServletContextListener</span><span style=color:#6e7681> </span><span style=color:#ff7b72>implements</span><span style=color:#6e7681> </span>ServletContextListener<span style=color:#6e7681> </span>{<span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681>    </span><span style=color:#d2a8ff;font-weight:700>@Override</span><span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681>    </span><span style=color:#ff7b72>public</span><span style=color:#6e7681> </span><span style=color:#ff7b72>void</span><span style=color:#6e7681> </span><span style=color:#d2a8ff;font-weight:700>contextInitialized</span>(ServletContextEvent<span style=color:#6e7681> </span>servletContextEvent)<span style=color:#6e7681> </span>{<span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681>        </span>ServletContext<span style=color:#6e7681> </span>servletContext<span style=color:#6e7681> </span><span style=color:#ff7b72;font-weight:700>=</span><span style=color:#6e7681> </span>servletContextEvent.getServletContext();<span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681>        </span>FilterRegistration.Dynamic<span style=color:#6e7681> </span>asynchronousFilterRegistration<span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681>                </span><span style=color:#ff7b72;font-weight:700>=</span><span style=color:#6e7681> </span>servletContext.addFilter(<span style=color:#a5d6ff>&#34;asynchronousFilter&#34;</span>,<span style=color:#6e7681> </span>AsynchronousFilter.class);<span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681>        </span>asynchronousFilterRegistration.addMappingForUrlPatterns(EnumSet.of(DispatcherType.REQUEST),<span style=color:#6e7681> </span><span style=color:#79c0ff>true</span>,<span style=color:#6e7681> </span><span style=color:#a5d6ff>&#34;/asynchronous&#34;</span>);<span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681>        </span>asynchronousFilterRegistration.setAsyncSupported(<span style=color:#79c0ff>true</span>);<span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681>    </span>}<span style=color:#6e7681>
</span></span></span><span style=display:flex><span><span style=color:#6e7681></span>}<span style=color:#6e7681>
</span></span></span></code></pre></div><p>与 Servlet 开启异步处理的支持一样，无论通过上述哪种方法开启过滤器对异步处理的支持，这仅仅表明指定的过滤器可以或能够支持异步处理。如果需要开启一个异步处理，还需要调用 ServletRequest 接口中的 <code>startAsync()</code> 或 <code>startAsync(ServletRequest servletRequest, ServletResponse servletResponse)</code> 方法，将请求置于异步模式。</p><p>如果过滤器仅是开启了对异步处理的支持，而过滤器或 Servlet 没有调用任何的 startAsync 方法，那么容器会将该过滤器按照同步的方式处理请求。这意味着一个开启的异步处理的过滤器即可以处理异步请求也可以处理同步请求。如果在过滤器中没有开启对异步处理的支持，但却尝试在过滤器或 Servlet 中调用任何的 startAsync 方法，那么容器都会抛出 IllegalStateException 异常。</p></div><div style="text-align:center;color:#a9a9a9;width:50%;margin:0 auto"><p>本作品采用<a href=http://creativecommons.org/licenses/by-nc-nd/4.0/ style=color:#a9a9a9>知识共享署名-非商业性使用-禁止演绎 4.0 国际许可协议</a>进行许可</p></div><div style="border-bottom-style:dashed;border-bottom-style:inset;border-bottom-width:2px;width:50%;margin:0 auto"></div><footer><div class=comments><script>let getTheme=window.localStorage&&window.localStorage.getItem("colorscheme");getTheme=getTheme??"light";let s=document.createElement("script");s.src="https://giscus.app/client.js",s.setAttribute("data-repo","csmervyn/csmervyn.github.io"),s.setAttribute("data-repo-id","R_kgDOGbYn4A"),s.setAttribute("data-category","Announcements"),s.setAttribute("data-category-id","DIC_kwDOGbYn4M4CWQYR"),s.setAttribute("data-mapping","pathname"),s.setAttribute("data-term",""),s.setAttribute("data-strict","0"),s.setAttribute("data-reactions-enabled","1"),s.setAttribute("data-emit-metadata","0"),s.setAttribute("data-input-position","bottom"),s.setAttribute("data-theme",getTheme),s.setAttribute("data-lang","zh-CN"),s.setAttribute("data-loading",""),s.setAttribute("crossorigin","anonymous"),s.setAttribute("async",""),document.querySelector("div.comments").innerHTML="",document.querySelector("div.comments").appendChild(s)</script></div></footer></article></section></div><footer class=footer><section class=container>©
2019 -
2025
Mervyn
·
技术支持 <a href=https://gohugo.io/ target=_blank rel=noopener>Hugo</a> & <a href=https://github.com/luizdepra/hugo-coder/ target=_blank rel=noopener>Coder</a>.</section></footer></main><script src=/js/coder.min.6ae284be93d2d19dad1f02b0039508d9aab3180a12a06dcc71b0b0ef7825a317.js integrity="sha256-auKEvpPS0Z2tHwKwA5UI2aqzGAoSoG3McbCw73gloxc="></script></body></html>