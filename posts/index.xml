<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Posts on 墨客人生</title><link>http://example.org/posts/</link><description>Recent content in Posts on 墨客人生</description><generator>Hugo</generator><language>zh-cn</language><lastBuildDate>Mon, 08 Dec 2025 15:57:42 +0700</lastBuildDate><atom:link href="http://example.org/posts/index.xml" rel="self" type="application/rss+xml"/><item><title>StreamingResponseBody 异步异常处理实践</title><link>http://example.org/posts/spring-boot/how-to-handle-exception-when-async-timeout-or-error-during-stream-reponse-body/</link><pubDate>Mon, 08 Dec 2025 15:57:42 +0700</pubDate><guid>http://example.org/posts/spring-boot/how-to-handle-exception-when-async-timeout-or-error-during-stream-reponse-body/</guid><description>&lt;h2 id="分块传输"&gt;
 分块传输
 &lt;a class="heading-link" href="#%e5%88%86%e5%9d%97%e4%bc%a0%e8%be%93"&gt;
 &lt;i class="fa-solid fa-link" aria-hidden="true" title="链接到标题"&gt;&lt;/i&gt;
 &lt;span class="sr-only"&gt;链接到标题&lt;/span&gt;
 &lt;/a&gt;
&lt;/h2&gt;
&lt;p&gt;Transfer-Encoding 是一个在 HTTP/1.1 被添加进来的 HTTP 的首部。其值可以是 chunked、compress、gzip、deflate。其中值为 chunked 时表示采用分块传输，意思是报文里的 body 部分不是一次性发过来的，而是分成了许多的块（chunk）逐个发送。其模式是一次请求，一次响应，并在连接不断开的情况下，分多次把多个 chunk 发回请求方，如图1 所示。&lt;/p&gt;</description></item><item><title>RestTemplate 的 read timed out issue</title><link>http://example.org/posts/spring-boot/rest-template/read-timeout-of-rest-template/</link><pubDate>Wed, 26 Nov 2025 10:43:10 +0700</pubDate><guid>http://example.org/posts/spring-boot/rest-template/read-timeout-of-rest-template/</guid><description>&lt;p&gt;我们维护了两个微服务，微服务 A 和微服务 B。如图1所示微服务 A 通过 RestTemplate 调用微服务 B。其中微服务A的 RestTemplate 通过 HTTPClient 设置了 Read Timeout 为15秒。但是微服务 B 中接口的响应有时候会超过 15秒，这就导致微服务 A 返回第三方微服务的请求会报 500 internal error。&lt;/p&gt;</description></item><item><title>如何 renew SSL 证书</title><link>http://example.org/posts/ssl/how-to-renew-ssl-certificate/</link><pubDate>Tue, 25 Nov 2025 18:33:29 +0700</pubDate><guid>http://example.org/posts/ssl/how-to-renew-ssl-certificate/</guid><description>&lt;p&gt;我们维护着一个微服务A，其第三方通过 HTTPS 与微服务A 进行交互。微服务A 需要 SSL certificate,并且 该 certificate 即将过期，我们需要及时 renew 该 certificate。
通过下面的图 1，我们来记录 renew certificate 的流程。&lt;/p&gt;</description></item><item><title>如何使用 cURL 命令发起具有 NTLM 认证的请求</title><link>http://example.org/posts/curl/how-to-use-curl-for-ntlm-protocol/</link><pubDate>Wed, 11 Jun 2025 16:47:21 +0700</pubDate><guid>http://example.org/posts/curl/how-to-use-curl-for-ntlm-protocol/</guid><description>&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;&lt;code class="language-shell" data-lang="shell"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;curl &lt;span style="color:#a5d6ff"&gt;&amp;#39;http://your-api/search&amp;#39;&lt;/span&gt; -vv --ntlm -u &lt;span style="color:#a5d6ff"&gt;&amp;#34;yourAccount:yourPassword&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description></item><item><title>利用 Bastion 转发流量</title><link>http://example.org/posts/ssh/use-bastion-to-forward-traffic/</link><pubDate>Wed, 11 Jun 2025 15:33:33 +0700</pubDate><guid>http://example.org/posts/ssh/use-bastion-to-forward-traffic/</guid><description>&lt;p&gt;对于测试环境上的数据库A，他位于AWS 上 VPC 中。我们的 Bastion 和数据库 A 在同一个 VPC 中。Bastion 可以访问数据库 A。并且 Bastion 具有公网的IP。那我们可以使用 Bastion 对流量进行转发，从而达到本地可以直接访问数据库A的目的。
示例代码如下：&lt;/p&gt;</description></item><item><title>Oauth 2.0 的 Client Credentials Grant 授权模式</title><link>http://example.org/posts/oauth2/client-credentials-grant/</link><pubDate>Sun, 16 Feb 2025 08:51:00 +0700</pubDate><guid>http://example.org/posts/oauth2/client-credentials-grant/</guid><description>&lt;p&gt;Oauth 2.0 支持客户端的多种授权模式来获取 Access Token，包含 Authorization Code Grant、Implicit Grant、Resource Owner Password Credentials Grant、&lt;a href="https://datatracker.ietf.org/doc/html/rfc6749#section-4.4" class="external-link" target="_blank" rel="noopener"&gt;Client Credentials Grant&lt;/a&gt; 等。&lt;/p&gt;</description></item><item><title>在 Spring Boot 中如何使用 OAuth 2.0 Client</title><link>http://example.org/posts/spring-boot/how-to-use-oauth-2-client-in-spring-boot/</link><pubDate>Sat, 15 Feb 2025 10:10:42 +0700</pubDate><guid>http://example.org/posts/spring-boot/how-to-use-oauth-2-client-in-spring-boot/</guid><description>&lt;h1 id="背景"&gt;
 背景
 &lt;a class="heading-link" href="#%e8%83%8c%e6%99%af"&gt;
 &lt;i class="fa-solid fa-link" aria-hidden="true" title="链接到标题"&gt;&lt;/i&gt;
 &lt;span class="sr-only"&gt;链接到标题&lt;/span&gt;
 &lt;/a&gt;
&lt;/h1&gt;
&lt;p&gt;目前有两个微服务 A 和 B，微服务 A 访问微服务 B 之前需要从授权服务器中获取 Access Token，才能携带 Access Token 访问微服务 B 中的 Restful API，如图 1 所示。微服务 A 使用客户端模式（Client Credentials Grant）的方式，从授权服务器获取 Access Token。目前微服务 A 通过 RestTemplate，从授权服务器获取 Access Token，并通过 Ehcache 来缓存 Access Token。&lt;/p&gt;</description></item><item><title>软件研发人员的质量保证实践【部分】</title><link>http://example.org/posts/servlet-book/quality-assurance-practices-for-software-developers/</link><pubDate>Sun, 09 Feb 2025 21:48:32 +0700</pubDate><guid>http://example.org/posts/servlet-book/quality-assurance-practices-for-software-developers/</guid><description>&lt;h3 id="1191-进程内集成测试"&gt;
 11.9.1 进程内集成测试
 &lt;a class="heading-link" href="#1191-%e8%bf%9b%e7%a8%8b%e5%86%85%e9%9b%86%e6%88%90%e6%b5%8b%e8%af%95"&gt;
 &lt;i class="fa-solid fa-link" aria-hidden="true" title="链接到标题"&gt;&lt;/i&gt;
 &lt;span class="sr-only"&gt;链接到标题&lt;/span&gt;
 &lt;/a&gt;
&lt;/h3&gt;
&lt;p&gt;进程内集成测试是一种针对应用程序内部组件和模块之间的集成进行测试的方法。它主要关注应用程序内部各个组件之间的协同工作、通信和数据流，以验证它们在应用程序运行时是否能够正确地交互和合作。&lt;/p&gt;</description></item><item><title>第八章 协议升级和非阻塞 IO【部分】</title><link>http://example.org/posts/servlet-book/protocal-upgrades-and-no-blocking-io/</link><pubDate>Sun, 09 Feb 2025 21:31:20 +0700</pubDate><guid>http://example.org/posts/servlet-book/protocal-upgrades-and-no-blocking-io/</guid><description>&lt;p&gt;Servlet 所提供的非阻塞 IO 仅可以在 Servlet 异步处理和协议升级中使用。我们在第七章已经详细阐述了 Servlet 异步处理，因此本章首先简单阐述 Servlet 对协议升级的支持，然后重点阐述 Servlet 为支持非阻塞 IO 所提供的相关 API 以及通过示例来说明它们的使用场景和用法。&lt;/p&gt;</description></item><item><title>第七章 异步处理【部分】</title><link>http://example.org/posts/servlet-book/asynchronous/</link><pubDate>Sun, 09 Feb 2025 20:46:04 +0700</pubDate><guid>http://example.org/posts/servlet-book/asynchronous/</guid><description>&lt;p&gt;本章将介绍 Servlet API 3.0 引入的对异步处理的支持。异步处理是为了减少同步处理中会出现的阻塞和等待问题，对系统吞吐率等影响。通过异步处理可以充分利用服务器资源，提高系统性能和响应速度。本章将从尝试回答异步处理尝试解决的问题开始，逐步介绍 Servlet API 对异步处理的支持和异步处理的典型顺序。紧接着通过具体的示例演示异步处理的过程，让读者对 Servlet 的异步处理有一个直观的认识并体会其优势。最后也会阐述异步处理具体的适用场景。通过学习本章，您将能够了解 Servlet 异步处理的基本概念和实现方式，以及如何利用其提高系统的性能。&lt;/p&gt;</description></item><item><title>Spring Boot 中如何设置 serializer 的 TimeZone</title><link>http://example.org/posts/how_to_configure_timezone_for_serializer_in_spring_boot/</link><pubDate>Sun, 24 Nov 2024 22:03:04 +0800</pubDate><guid>http://example.org/posts/how_to_configure_timezone_for_serializer_in_spring_boot/</guid><description>&lt;h2 id="1-背景"&gt;
 1 背景
 &lt;a class="heading-link" href="#1-%e8%83%8c%e6%99%af"&gt;
 &lt;i class="fa-solid fa-link" aria-hidden="true" title="链接到标题"&gt;&lt;/i&gt;
 &lt;span class="sr-only"&gt;链接到标题&lt;/span&gt;
 &lt;/a&gt;
&lt;/h2&gt;
&lt;p&gt;在一个基于 Spring Boot 的服务中，对外提供一个 Restful 接口 A。该接口的返回值类型中包含一个 ZonedDateTime 类型的字段 createdDateTime。Prod 代码侧期望返回时区为 Australia/Sydney（UTC+10/UTC+10）的时间，并带有时区信息，例如，2024-11-03T08:23:24+11:00。并且测试侧代码也是按照期望进行了测试，测试在 Pipeline 和澳洲 Dev 的本地电脑中可以通过。测试示例如代码1所示。但是该代码确不能在中国 Dev 的本地电脑上工作。&lt;/p&gt;</description></item><item><title>Gradle 的 org.springframework.boot 插件与 io.spring.dependency-management 插件的关系</title><link>http://example.org/posts/the-relationship-between-spring-boot-plugin-and-dependency-management-plugin/</link><pubDate>Tue, 22 Oct 2024 20:07:47 +0800</pubDate><guid>http://example.org/posts/the-relationship-between-spring-boot-plugin-and-dependency-management-plugin/</guid><description>&lt;h1 id="gradle-的-orgspringframeworkboot-插件与-iospringdependency-management-插件的关系"&gt;
 Gradle 的 org.springframework.boot 插件与 io.spring.dependency-management 插件的关系
 &lt;a class="heading-link" href="#gradle-%e7%9a%84-orgspringframeworkboot-%e6%8f%92%e4%bb%b6%e4%b8%8e-iospringdependency-management-%e6%8f%92%e4%bb%b6%e7%9a%84%e5%85%b3%e7%b3%bb"&gt;
 &lt;i class="fa-solid fa-link" aria-hidden="true" title="链接到标题"&gt;&lt;/i&gt;
 &lt;span class="sr-only"&gt;链接到标题&lt;/span&gt;
 &lt;/a&gt;
&lt;/h1&gt;
&lt;p&gt;最近在升级一个 Spring Boot 的应用的 Spring Boot 的版本，对 &lt;a href="https://plugins.gradle.org/plugin/org.springframework.boot" class="external-link" target="_blank" rel="noopener"&gt;org.springframework.boot&lt;/a&gt; 插件的版本和 &lt;a href="https://plugins.gradle.org/plugin/io.spring.dependency-management" class="external-link" target="_blank" rel="noopener"&gt;io.spring.dependency-management&lt;/a&gt; 插件的版本的关系产生了疑问。当时以为 org.springframework.boot 插件的版本和 io.spring.dependency-management 插件的版本，可能有某种映射关系。&lt;/p&gt;</description></item><item><title>解决 java.lang.OutOfMemoryError: Metaspace</title><link>http://example.org/posts/fix-outofmemoryerror-of-metaspace/</link><pubDate>Wed, 22 May 2024 12:34:42 +0800</pubDate><guid>http://example.org/posts/fix-outofmemoryerror-of-metaspace/</guid><description>&lt;h2 id="问题描述"&gt;
 问题描述
 &lt;a class="heading-link" href="#%e9%97%ae%e9%a2%98%e6%8f%8f%e8%bf%b0"&gt;
 &lt;i class="fa-solid fa-link" aria-hidden="true" title="链接到标题"&gt;&lt;/i&gt;
 &lt;span class="sr-only"&gt;链接到标题&lt;/span&gt;
 &lt;/a&gt;
&lt;/h2&gt;
&lt;p&gt;近日发现有一个微服务在运行时出现了 &lt;code&gt;java.lang.OutOfMemoryError: Metaspace&lt;/code&gt; 的错误。这个错误是由于 &lt;code&gt;Metaspace&lt;/code&gt; 区域内存不足导致的。&lt;code&gt;Metaspace&lt;/code&gt; 是 Java 8 之后取代了永久代的区域，用于存放类的元数据信息。Metaspace 是在本地内存中分配的，不受 Java 堆大小的限制，但是受本地内存大小的限制。
当 &lt;code&gt;Metaspace&lt;/code&gt; 区域内存不足时，会抛出 &lt;code&gt;java.lang.OutOfMemoryError: Metaspace&lt;/code&gt; 错误。Metaspace 在 Java 虚拟机内存中的位置如图1所示：&lt;/p&gt;</description></item><item><title>在 Mac M1 上安装 Memory Analyzer</title><link>http://example.org/posts/install-memory-analyzer-on-mac-m1/</link><pubDate>Sun, 31 Mar 2024 11:38:29 +0800</pubDate><guid>http://example.org/posts/install-memory-analyzer-on-mac-m1/</guid><description>&lt;h1 id="下载-memory-analyzer"&gt;
 下载 Memory Analyzer
 &lt;a class="heading-link" href="#%e4%b8%8b%e8%bd%bd-memory-analyzer"&gt;
 &lt;i class="fa-solid fa-link" aria-hidden="true" title="链接到标题"&gt;&lt;/i&gt;
 &lt;span class="sr-only"&gt;链接到标题&lt;/span&gt;
 &lt;/a&gt;
&lt;/h1&gt;
&lt;p&gt;如图1-1所示，通过&lt;a href="https://eclipse.dev/mat/downloads.php" class="external-link" target="_blank" rel="noopener"&gt;Memory Analyzer 下载地址&lt;/a&gt;下载 ARM 架构的 Memory Analyzer。直接安装下载好的dmg文件即可。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://example.org/install-Memory-Analyzer-on-Mac-M1/download-memory-analyzer.png" alt="下载 ARM 架构的 Memory Analyzer"&gt;&lt;/p&gt;
&lt;p&gt;图1-1 下载 ARM 架构的 Memory Analyzer&lt;/p&gt;</description></item><item><title>如何修改最后一次 commit 的 author 信息</title><link>http://example.org/posts/git/change-the-author-of-last-commit/</link><pubDate>Sat, 20 Jan 2024 09:56:01 +0800</pubDate><guid>http://example.org/posts/git/change-the-author-of-last-commit/</guid><description>&lt;p&gt;在新 repository 提交代码时，有时忘记配置该 repository scope 内的 &lt;code&gt;user.name&lt;/code&gt; 和 &lt;code&gt;user.email&lt;/code&gt;，从而导致 commit 的 author 信息为 global 配置的 &lt;code&gt;user.name&lt;/code&gt; 和 &lt;code&gt;user.email&lt;/code&gt;。如果此时想要修改最新提交的 author 信息，可以使用下面的 command:&lt;/p&gt;</description></item><item><title>由 Reactor Netty HttpClient 的 response-timeout 设置错误引发的生产事故的反思</title><link>http://example.org/posts/rethink-of-production-incident-caused-by-the-wrong-configuration-of-respond-timeout-in-terms-of-reactor-netty-httpclient/</link><pubDate>Wed, 17 Jan 2024 05:07:38 +0800</pubDate><guid>http://example.org/posts/rethink-of-production-incident-caused-by-the-wrong-configuration-of-respond-timeout-in-terms-of-reactor-netty-httpclient/</guid><description>&lt;p&gt;在 onCall 的过程中，发生了一起由 Reactor Netty HttpClient 的 response-timeout 设置错误引发的 P2 级生产事故。造成了系统 1.5 小时部分功能不可用，使客户遭受了经济上的损失。本文期望针对完整的事件进行复盘与反思，以加强自己对线上环境的敬畏。&lt;/p&gt;</description></item><item><title>How to Set Username and Email in Git</title><link>http://example.org/posts/git/how-to-set-username-and-email-in-git/</link><pubDate>Tue, 26 Dec 2023 20:10:48 +0800</pubDate><guid>http://example.org/posts/git/how-to-set-username-and-email-in-git/</guid><description>&lt;p&gt;Git 中的 &lt;code&gt;user.name&lt;/code&gt; 和 &lt;code&gt;user.email&lt;/code&gt; 的 scope 的范围可以为单个 repository 的或全局的。利用这点上下文，我们可以很好解决多个 repository 中的 commit 需要不同 &lt;code&gt;Author&lt;/code&gt; 的问题。下面首先分别阐述如何设置 scope 为单个 repository 和如何设置全局的的&lt;code&gt;user.name&lt;/code&gt; 和 &lt;code&gt;user.email&lt;/code&gt;。&lt;/p&gt;</description></item><item><title>如何构建自己的个人博客</title><link>http://example.org/posts/config-personal-website/how-to-create-your-personal-website/</link><pubDate>Thu, 04 May 2023 13:31:11 +0800</pubDate><guid>http://example.org/posts/config-personal-website/how-to-create-your-personal-website/</guid><description>&lt;p&gt;构建属于自己的个人博客系统，往往涉及多方面的问题。例如：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用哪个 framework 构建自己的博客系统&lt;/li&gt;
&lt;li&gt;使用哪个内容托管平台托管自己的静态网友&lt;/li&gt;
&lt;li&gt;域名绑定&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id="1-使用-hugo-构建个人博客"&gt;
 1 使用 Hugo 构建个人博客
 &lt;a class="heading-link" href="#1-%e4%bd%bf%e7%94%a8-hugo-%e6%9e%84%e5%bb%ba%e4%b8%aa%e4%ba%ba%e5%8d%9a%e5%ae%a2"&gt;
 &lt;i class="fa-solid fa-link" aria-hidden="true" title="链接到标题"&gt;&lt;/i&gt;
 &lt;span class="sr-only"&gt;链接到标题&lt;/span&gt;
 &lt;/a&gt;
&lt;/h1&gt;
&lt;h2 id="11-安装与配置-hugo"&gt;
 1.1 安装与配置 Hugo
 &lt;a class="heading-link" href="#11-%e5%ae%89%e8%a3%85%e4%b8%8e%e9%85%8d%e7%bd%ae-hugo"&gt;
 &lt;i class="fa-solid fa-link" aria-hidden="true" title="链接到标题"&gt;&lt;/i&gt;
 &lt;span class="sr-only"&gt;链接到标题&lt;/span&gt;
 &lt;/a&gt;
&lt;/h2&gt;
&lt;h3 id="111-安装-hugo"&gt;
 1.1.1 安装 Hugo
 &lt;a class="heading-link" href="#111-%e5%ae%89%e8%a3%85-hugo"&gt;
 &lt;i class="fa-solid fa-link" aria-hidden="true" title="链接到标题"&gt;&lt;/i&gt;
 &lt;span class="sr-only"&gt;链接到标题&lt;/span&gt;
 &lt;/a&gt;
&lt;/h3&gt;
&lt;p&gt;如果是 Mac os 可以使用包管理器进行安装 Hugo。&lt;/p&gt;</description></item></channel></rss>